# 기술면접 질문

## Java

### 1. 자바란 무엇인가?

호환이 좋은 객체 지향언어

<br>

### 2. 절차지향 언어와 객체지향언어

**절차지향 언어**

- 실행하고자 하는 절차를 정하고, 이 절차대로 프로그래밍하는 방법
  목적을 달성하기 위한 일의 흐름에 중점을 둔다.
- 장점
  - 컴퓨터의 처리구조와 유사해 실행속도가 빠름
- 단점
  - 유지보수, 디버깅이 어려움
  - 실행 순서가 정해져 있으므로 코드의 순서가 바뀌면 동일한 결과를 보장하기 어려움

**객체지향 언어**

- 유지보수 디버깅이 절차지향언어 보다 비교적 수월하고 
- 실세상의 물체를 객체로 표현하고, 이들 사이의 관계, 상호 작용을 프로그램으로 나타낸다.
- 객체를 추출하고 객체들의 관계를 결정하고 이들의 상호 작용에 필요한 함수(메서드)와 변수(필드)를 설계 및 구현하다.
- 객체 지향의 행심은 연관되어 있는 변수와 메서드를 하나의 그룹으로 묶어서 그룹핑하는 것이다.
- 사람의 사고와 가장 비슷하게 프로그래밍을 하기 위해서 생성된 기법
- 하나의 클래스를 바탕으로 서로 다른 상태를 가진 인스턴스를 만들면 서로 다른 행동을 하게 된다. 즉, 하나의 클래스가 여러 개의 인스턴스가 될 수 있다는 점이 객체 지향이 제공하는 가장 기본적인 재활용성이라고 할 수 있다.

<br>

### 3. 데이터 타입과 변수란?

**Data Type 이란**

- (Data type)이란 해당 데이터가 메모리에 어떻게 저장되고, 프로그램에서 어떻게 처리되어야 하는지를 명시적으로 알려주는 것이다. 자바에서 타입은 크게 기본형 타입과 참조형 타입이 있다.
- 값의 종류에 따라 값이 저장될 공간의 크기와 저장형식을 정의한 것이 자료형(Data Type)이다.

- 기본형 타입에는  boolean, char, byte, short, int, long, float, double와 같이 계산을 할 수 있는 타입이 있으며,

  참조형 타입(Reference Type)은 기본형을 제외한 나머지 타입을 의미합니다. String, StringBuffer, List 등등 개인이 만든 클래스도 참조형 타입이 될 수 있습니다. (Array, 열거형, Class, Interface 이며 기본값은 Null 이다)

  참조형 타입은 Heap 메모리 영역에 저장된다.

  

**변수란**

- 단 하나의 값을 저장할 수 있는 메모리 공간이다.

<br>

### 4. 문자는 char와 string으로 왜 나눠져 있는가?

<br>

### 5. Heap 영역과 Stack 영역에 대해 설명하시오 

- 그럼 heap영역만 있으면 안되나? 굳이 stack영역을 만든 이유가 뭐지?

<br>

### 6. string a ="1234";와  string b = new string("1234"); 차이와 어떤게 더 좋을지?

<br>

### 7. 오버로딩과 오버라이딩을 설명해 보세요

- 오버로딩은 같은 클래스내에서 같은 이름의 메서드를 재사용 하는 것이고

  (매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메서드를 정의할 수 있다.)

  - 오버로딩의 성립 조건
    1. 메서드의 이름이 같아야한다.
    2.  매개변수의 개수 또는 타입이 달라야 한다.

  가장 대표적인 예) println 메서드

- 오버라이딩은 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것이다.(자손 메서드의 상황에 맞게 변경)

즉 오버로딩은 기존에 없는 새로운 메서드(이름만 같은)를 추가하는 것이고,

오버라이딩은 조상으로부터 상속받은 메서드의 내용을 변경하는 것이다.



오버로딩을 사용하는 이유?

**동일한 기능의 메서드를 정의할 때 다양한 입력값(매개값)을 받기 위해서**이다. 프로그램이 거대해지면 메소드 또한 많아진다. 이때 동일한 기능의 메소드를 매개값에 따라 다르게 이름을 정의하면 복잡하고 관리하기가 어려울 것이다. **생성자 또한 외부로부터 입력되는 다양한 값으로 초기화를 하기 위해서** 사용된다.

ex) 우리가 흔히 콘솔창에 텍스트를 출력할 때 사용하는 println라는 메소드를 대표적인 예로 들어볼 수 있다. 

실은 이 함수가 오버로딩의 결정체이다. 우리는 println의 인자 값으로 int, double, boolean, String 등의 아주 다양한 타입의 매개변수들을 집어넣어도 우리는 그 함수들이 어떻게 실행되지는 모르지만 콘솔창에 아주 잘 출력해주는 것을 볼 수 있다.

이렇게 '출력하다.'라는 같은 기능을 가진 메소드들를 println이라는 하나의 이름으로 정의가 가능한 것이다.

이 메소드(println)를 매개변수의 종류에 따라서 다르게 지정한다고 생각해보자. printlnInt, printlnDouble, printlnBoolean 등 수많은 메소드들의 이름을 정해줘야 할 것이다. 이는 프로그래머의 입장에서는 메소드의 네이밍에 고민을 가중시킨다. 그리고 이런 이름들은 다른 곳에 사용할 가능성도 생기게 된다.

오버라이딩을 사용하는 이유?

자손 클래스에서 메서드의 기능이 변경되는 경우 용이하다.

<br>

### 8. JVM에 대해 설명해 보시오

**JVM(Java Virtual Machine)**은 Java byte code를 실행할 수 있는 주체이다.

운영체제 위에서 동작하는 프로세스로 자바 코드를 컴파일해서 얻은 바이트 코드를 해당 운영체제가 이해할 수 있는 기계어로 바꿔 실행시켜주는 역할을 한다.

중요한 것은 **운영체에에 의존적이지 않고 독립적으로 java 프로그램이 실행된다.**

자바로 작성된 애플리케이션은 모두 JVM에서만 실행되기 때문에, 자바 애플리케이션이 실행되기 위해서는 반드시 JVM이 필요하다.

일반 애플리케이션의 코드는 OS만 거치고 하드웨어로 전달되는데 비해 Java애플리케이션은 JVM을 한 번 더 거치기 때문에, 그리고 하드웨어에 맞게 완전히 컴파일 된 사태가 아니고 실행 시에 해석(interpret)되기 때문에 속도가 느리다는 단점을 가지고 있다.

그러나 요즘엔 바이트코드(컴파일된 자바코드)를 하드웨어의 기계어로 바로 변환해 주는 JIT 컴파일러와 향상된 최적화 기술이 적용되어서 속도의 격차를 많이 줄였다.

<br>

### 9. 가비지 컬렉터에 대해 설명해 보세요

Garbage Collector(GC)는 Heap 메모리 영역에 생성(적재)된 객체들 중에 참조되지 않는 객체들을 탐색 후 제거하는 역할을 한다.

GC가 수행되는 동안 GC를 수행하는 쓰레드가 아닌 다른 모든 쓰레드가 일시정지된다.

가비지 컬렉터는 어떤 객체들을 어떤 순서데로 제거 할까?

Garbage Collection 과정은 Mark and Sweep 이라고도 한다.

JVM의 Garbage Collector 가 스택(메소드 작업에 필요한 공간을 제공한다) 의 모든 변수를 스캔하면서 각각 어떤 오브젝트(Heap영역에 있다)를 레퍼런스 하고 있는지 찾는과정이 Mark 다. Reachable 오브젝트가 레퍼런스하고 있는 오브젝트 또한 marking 한다.

첫번째 단계인 marking 작업을 위해 모든 스레드는 중단되는데 이를 stop the world 라고 부르기도 한다. (System.gc() 를 생각없이 호출하면 안되는 이유이기도 하다)

그리고 나서 mark 되어있지 않은 모든 오브젝트들을 힙에서 제거하는 과정이 Sweep 이다.

Garbage Collection 이라고 하면 garbage 들을 수집할 것 같지만 실제로는 garbage 를 수집하여 제거하는 것이 아니라, garbage 가 아닌 것을 따로 mark 하고 그 외의 것은 모두 지우는 것이다. 만약 힙에 garbage 만 가득하다면 제거 과정은 즉각적으로 이루어진다.

<br>

### 10. equals 메서드와 '==' 의 차이는?

equals 메서드와 '==' 는 

객체가 참조하고 있는 주소값을 비교한다.

String 클래스가 equals 메서드를 오버라이딩 해서 사용하는데

String 클래스에서 equals 메서드는 내용 자체를 비교한다.

'==' 는 그대로 사용된다.

<br>

### 11. 추상클래스와 인터페이스의 차이는?

- **추상클래스**는
  - 객체(인스턴스)를 생성하기 위함이 아니며, **상속을 위한 부모 클래스로 활용하기 위한 것이다.**
    여러 클래스들의 **공통된 부분을 추상화(추상 메서드) 하여 상속받는 클래스에게 구현을 강제화하기 위한 것이다.** 
  - (메서드의 동작을 구현하는 자식 클래스로 책임을 위임)
    즉, 추상 클래스의 추상 메서드를 자식 클래스가 구체화하여 그 기능을 확장하는 데 목적이 있다.

- **추상메서드**는
  - 선언부와 구현부로 구성되어 있고, 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상메서드이다.
  - 즉, 설계만 해 놓고 실제 수행될 내용은 작성하지 않았기 때문에 미완성 메서드인 것이다.

<br>

- **인터페이스**는
  - 추상클래스 처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 몸통(구현부)을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 **가질 수 없다.**
  - 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속, 즉 여러개의 인터페이스로부터 상속 받는 것이 가능하다.-
- 인터페이스의 목적
  - 상속받을 서브 클래스에게 구현할 메서드들의 원형을 모두 알려주어, 클래스가 자신의 목적에 맞게 메서드를 구현하도록 하는 것이다.
    구현 객체의 같은 동작을 보장하기 위한 목적이 있다.
    즉, 서로 관련이 없는 클래스에서 공통적으로 사용하는 방식이 필요하지만 기능을 각각 구현할 필요가 있는 경우에 사용한다.
- **차이점**
  - 추상 클래스는 추상 메서드를 자식 클래스가 구체화하여 그 기능을 확장하는 데 목적이 있다. (상속을 위한 부모 클래스)
  - 인터페이스는 **서로 관련이 없는 클래스에서 공통적으로 사용하는 방식이 필요하지만 기능을 각각 구현할 필요가 있는 경우에 사용한다.** (구현 객체의 같은 동작을 보장)
  - 인터페이스(클래스가 아니다)는 클래스와 달리 다중상속이 가능하다.

<br>

### 12. HashCode란?



<br>

### 13. 다형성이란?

한 타입의 참조변수로 여러 타입 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다.

조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 한 것이다.

<br>

### 실제로 java 프로젝트 해본거 설명해 보시오

<br>

